MDM: 마크다운 멀티미디어 스토리텔링의 미래
MDM(Markdown+Media)은 직관적인 문법으로 이미지, 비디오, 오디오와 같은 로컬 멀티미디어 콘텐츠를 원활하게 삽입하고 제어하도록 설계된 마크다운의 상위 집합입니다. 이 프로젝트는 표준 마크다운의 깨진 미디어 링크 문제와 멀티미디어 제어 기능의 부재를 해결하여, 개인 지식 관리(PKM), 기술 문서 작성, 디지털 콘텐츠 제작에 완벽한 도구를 제공하는 것을 목표로 합니다.

참고: 이 프로젝트는 현재 사양 정의 및 초기 개발 단계에 있습니다. NPM/PyPI/Crates 배지는 향후 릴리스를 위한 플레이스홀더입니다.

🤔 문제점
표준 마크다운은 텍스트 작성에는 훌륭하지만, 로컬 미디어를 다루는 데에는 다음과 같은 한계가 있습니다.

깨지기 쉬운 경로: .md 파일을 이동하면 이미지 링크(../images/pic.png)가 깨지는 경우가 많습니다.

제어의 부재: HTML 태그 없이는 비디오 너비를 지정하거나, 자동 재생시키거나, 반복 재생할 수 없습니다.

제한된 미디어 유형: 오디오 파일을 삽입하거나 이미지 갤러리를 만드는 것은 번거롭고 비표준적입니다.

💡 해결책: ![[]] 문법
MDM은 강력하고 단일화된 문법인 ![[]]를 도입합니다. 이는 익숙한 마크다운 이미지 문법과 Obsidian 같은 도구에서 사용되는 "위키링크" 스타일을 직관적으로 확장한 것입니다.

🖼️ 이미지
단순한 이미지 표시를 넘어, 중앙 정렬, 캡션 추가, 스타일 적용 등 다양한 기능을 활용해 보세요.

마크다운

// 간단한 이미지 삽입
![[profile.jpg]]

// 속성을 포함한 이미지 (정렬, 너비, 대체 텍스트, 캡션)
![[brand-logo.png]{width=250px align=center alt="MDM 프로젝트 로고" caption="MDM 공식 로고"}]]

🎬 비디오 & 🔉 오디오
마크다운 문서 내에서 직접 비디오와 오디오 파일을 삽입하고 제어할 수 있습니다.

마크다운

// 컨트롤러, 지정된 크기, 자동 재생 비활성화를 포함한 비디오
![[product-demo.mp4]{width=720px controls=true autoplay=false}]]

// 반복 재생되는 음소거 배경 비디오
![[background-loop.mp4]{loop=true muted=true}]]

// 플레이어 컨트롤러를 포함한 오디오 파일 삽입
![[podcast-episode-1.mp3]{controls=true}]]

⚙️ .mdm 사이드카 파일: 작동 방식
MDM은 표준 마크다운과의 100% 호환성을 유지하기 위해, 선택적으로 .mdm 사이드카 파일을 사용합니다. 이 접근 방식은 미디어 설정을 콘텐츠와 분리하여 유연성과 이식성을 극대화합니다.

1. 파일 이름 규칙
기본 (1:1 매칭): 기본적으로 .md 파일은 동일한 디렉터리에 위치한 정확히 같은 이름의 .mdm 파일과 쌍을 이룹니다. 이것이 가장 기본적이고 직관적인 사용법입니다.

MyNote.md ↔ MyNote.mdm

공유 (N:1 매칭): 여러 .md 파일이 하나의 .mdm 설정 파일을 공유할 수 있습니다. 이를 위해 .md 파일의 YAML Front Matter에 .mdm 파일의 경로를 명시적으로 선언해야 합니다.

YAML

---
title: "1장: 서론"
# 이 문서는 프로젝트의 공유 미디어 설정을 사용합니다.
mdm_source: "../_shared_media.mdm" 
---

2. media_root 경로 해석
기준 디렉터리: media_root에 상대 경로가 지정되면, 그 경로는 항상 .mdm 파일의 위치를 기준으로 해석됩니다. 이를 통해 전체 프로젝트 폴더를 이동하거나 이름을 변경해도 미디어 링크가 깨지지 않고 유지됩니다.

예시: media_root: "./assets" 선언은 .mdm 파일과 동일한 디렉터리에 있는 assets 폴더를 가리킵니다.

🚀 기술 로드맵: 목표 및 주요 단계
MDM은 보편적인 접근성과 고성능을 모두 보장하기 위해 다국어 전략을 채택합니다.

1. JavaScript (NPM) - 웹 생태계의 허브
이유: 웹 개발자들의 접근성을 극대화하고 통합을 용이하게 하기 위함입니다. 이는 정적 사이트 생성기, 웹 기반 편집기(VS Code 확장 프로그램 등), 모든 프론트엔드 프로젝트에 이상적인 참조 구현이 될 것입니다.

주요 단계:
v0.1.0 (핵심 파싱 엔진) - 예상 2025년 4분기: 이미지 속성({width}, {align})을 포함한 ![[]] 문법의 기본 블록/인라인 파싱.
v0.2.0 (멀티미디어 및 사이드카) - 예상 2026년 1분기: <video>/<audio> 태그 지원 및 .mdm 사이드카 파일의 media_root 파싱.
v0.5.0 (안정 버전) - 예상 2026년 2분기: API 안정화, 포괄적인 버그 수정 및 공식 문서 완성.

2. Python (PyPI) - 데이터 및 도구의 백본
이유: 데이터 과학(Jupyter), 머신러닝 문서, 백엔드 프레임워크, MkDocs와 같은 인기 있는 정적 사이트 생성기 등 방대한 Python 생태계에 MDM을 통합하기 위함입니다.

주요 단계:
v0.1.0 (초기 포팅) - 예상 2026년 2분기: JavaScript v0.2.0 기능 전체를 Python으로 포팅.
v0.2.0 (생태계 통합) - 예상 2026년 3분기: Jupyter, MkDocs 등 핵심 라이브러리를 위한 프로토타입 플러그인 또는 확장 기능 개발.

3. Rust - 성능의 핵심
이유: 실시간 편집기 렌더링 및 대규모 문서 처리와 같이 까다로운 애플리케이션을 위해 초고속 성능을 제공하기 위함입니다. 궁극적으로 이 Rust 코어는 WASM(웹용) 및 네이티브 모듈(Python/Node.js용)으로 컴파일되어 다른 모든 구현에 성능을 제공할 것입니다.

주요 단계:
v0.1.0 (Rust 핵심 로직) - 예상 2026년 3분기: JS/Python 버전으로 검증된 핵심 파싱 로직을 Rust로 구현.
v0.2.0 (WASM & FFI) - 예상 2026년 4분기: JS 파서의 성능을 높이기 위해 코어를 WASM으로 컴파일하고, FFI(Foreign Function Interface)를 사용하여 네이티브 Python 모듈을 생성하는 작업 시작.

🤝 기여하는 방법
MDM은 오픈소스 프로젝트이며 모든 종류의 기여를 환영합니다! 참여 방법에 대한 자세한 지침은 CONTRIBUTING.md 파일을 참조해 주세요.

📜 라이선스
MDM 사양 및 문서는 Creative Commons BY-SA 4.0 라이선스가 적용됩니다.
모든 소스 코드는 MIT 라이선스가 적용됩니다.

CONTRIBUTING.md (초안)
MDM에 기여하기
MDM 프로젝트에 관심을 가져주셔서 감사합니다! 우리는 활기찬 커뮤니티를 만드는 데 기여해주시는 모든 분들을 환영합니다. 버그 리포트, 기능 제안부터 코드 및 문서 기여까지 모든 형태의 참여를 환영합니다.

행동 강령
이 프로젝트와 참여하는 모든 사람은 우리의 행동 강령에 의해 관리됩니다. 참여함으로써 귀하는 이 강령을 준수할 것을 약속해야 합니다.

버그 리포트 또는 기능 제안 방법
버그 리포트: GitHub 이슈에서 "Bug Report" 템플릿을 사용해 주세요. 명확하고 상세한 설명과 함께 문제를 재현할 수 있는 단계를 제공해 주세요.

기능 제안: GitHub 이슈에서 "Feature Request" 템플릿을 사용하여 제안의 동기와 구체적인 사용 사례를 설명해 주세요.

코드 기여 가이드
1. 환경 설정
(각 언어별 환경 설정 지침이 여기에 추가될 예정입니다.)

2. 코드 스타일 가이드
일관된 코드베이스를 유지하기 위해 각 언어에 맞는 표준 포매터와 린터를 사용합니다. Pull Request를 제출하기 전에 코드가 이러한 스타일을 준수하는지 확인해 주세요.

JavaScript (ESLint):
루트의 .eslintrc.json 파일에 있는 규칙을 따라주세요. npm run lint를 실행하여 코드를 확인할 수 있습니다.
ESLint 설정 보기

Python (Black & Flake8):
모든 Python 코드는 Black을 사용하여 포맷해야 합니다.
Black에 대해 더 알아보기

Rust (Rustfmt):
표준 Rust 포매터인 rustfmt를 사용합니다. cargo fmt를 실행하여 코드를 포맷할 수 있습니다.
Rustfmt 문서 읽기

3. Pull Request 프로세스
저장소를 포크하고 main에서 기능 브랜치를 생성합니다 (git checkout -b feature/AmazingFeature).

변경 사항을 적용하고 코드가 올바르게 포맷되었는지 확인합니다.

변경 사항을 다루는 테스트를 추가합니다.

명확한 커밋 메시지와 함께 변경 사항을 커밋합니다 (git commit -m 'feat: Add some AmazingFeature').

포크한 저장소로 푸시합니다 (git push origin feature/AmazingFeature).

메인 저장소로 Pull Request를 열고 변경 사항에 대한 자세한 설명을 제공합니다.
